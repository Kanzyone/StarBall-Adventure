<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star Ball Adventure: Pro Edition</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #000; }
        
        /* UI Elements */
        #game-ui {
            position: absolute; top: 20px; left: 20px; color: gold;
            font-size: 24px; font-weight: bold; text-shadow: 2px 2px 4px #000;
            pointer-events: none; z-index: 10; display: none;
        }
        #top-right-ui {
            position: absolute; top: 20px; right: 20px; color: #00ffcc;
            font-size: 24px; font-weight: bold; text-shadow: 2px 2px 4px #000;
            z-index: 110;
        }

        /* Geri Dön Butonu Stil */
        .back-btn {
            position: absolute; top: 20px; left: 20px;
            width: 50px; height: 50px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: white; border: 2px solid white;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; z-index: 150; font-size: 24px;
            transition: all 0.2s;
        }
        .back-btn:hover { background: white; color: black; transform: scale(1.1); }
        
        /* Screens */
        .overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.95); z-index: 100; color: white;
        }
        .menu-btn {
            background: linear-gradient(135deg, #ffcc00, #ff9900);
            border: none; padding: 15px 40px; margin: 10px; font-size: 24px;
            font-weight: bold; color: #000; border-radius: 50px; cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s; min-width: 220px;
            text-transform: uppercase;
        }
        .menu-btn:hover { transform: scale(1.05); box-shadow: 0 0 20px gold; }
        .menu-btn.secondary { background: linear-gradient(135deg, #00ccff, #0066ff); color: white; }
        .menu-btn.lobby { background: linear-gradient(135deg, #666, #333); color: white; font-size: 16px; padding: 10px 25px; }

        /* Level Grid */
        #level-buttons { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; }
        .lvl-card { position: relative; text-align: center; }
        .lvl-status { font-size: 12px; color: #00ff00; font-weight: bold; margin-bottom: 5px; height: 15px; }

        /* Shop Grid */
        #shop-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-top: 20px; }
        .shop-item {
            background: rgba(255,255,255,0.05); padding: 20px; border-radius: 15px;
            text-align: center; border: 2px solid transparent; width: 140px;
            transition: background 0.3s;
        }
        .shop-item.selected { border-color: gold; background: rgba(255,215,0,0.15); }
        .ball-preview {
            width: 60px; height: 60px; border-radius: 50%; margin: 0 auto 15px;
            box-shadow: inset -10px -10px 20px rgba(0,0,0,0.5), 0 5px 15px rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
        }
        .price-tag { color: gold; font-weight: bold; display: block; margin-bottom: 10px; }

        #message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 32px; text-align: center; display: none;
            text-shadow: 0 0 20px rgba(0,0,0,1); z-index: 200;
            background: rgba(0,0,0,0.95); padding: 50px; border-radius: 20px; border: 4px solid gold;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 40px; height: 40px;
            border: 2px solid rgba(0,255,255,0.7); border-radius: 50%; transform: translate(-50%, -50%);
            display: none; pointer-events: none; z-index: 15;
        }
    </style>
</head>
<body>
    <!-- Main Menu -->
    <div id="main-menu" class="overlay-screen">
        <h1 style="font-size: 50px; color: gold; margin-bottom: 30px; text-shadow: 0 0 20px orange;">STAR BALL ADVENTURE</h1>
        <button class="menu-btn" onclick="showLevelSelect()">PLAY GAME</button>
        <button class="menu-btn secondary" onclick="openShop()">STORE</button>
    </div>

    <!-- Level Select -->
    <div id="level-select" class="overlay-screen" style="display:none;">
        <div class="back-btn" onclick="backToMenu()">&#8592;</div>
        <h2 style="color:gold">SELECT LEVEL</h2>
        <div id="level-buttons"></div>
    </div>

    <!-- Store -->
    <div id="shop-screen" class="overlay-screen" style="display:none;">
        <div class="back-btn" onclick="backToMenu()">&#8592;</div>
        <h2 style="color:gold">BALL STORE</h2>
        <div id="shop-grid"></div>
    </div>

    <!-- Game HUD -->
    <div id="top-right-ui">COINS: <span id="global-coins">0</span></div>
    <div id="game-ui">
        LEVEL: <span id="current-level-display">1</span> | 
        STARS: <span id="score">0</span> / <span id="target-score">10</span>
    </div>

    <div id="message">
        <div id="msg-content"></div>
        <div style="margin-top:30px; display:flex; gap:10px; justify-content:center;">
            <button id="next-lvl-btn" class="menu-btn" style="padding:10px 20px; font-size:18px;">NEXT LEVEL</button>
            <button class="menu-btn secondary" style="padding:10px 20px; font-size:18px;" onclick="backToMenu()">LOBBY</button>
        </div>
    </div>

    <div id="crosshair"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- State Management ---
        let scene, camera, renderer, player, playerBall, clock;
        let score = 0;
        let globalCoins = parseInt(localStorage.getItem('starball_coins')) || 0;
        let currentLevel = 1;
        let completedLevels = JSON.parse(localStorage.getItem('starball_completed')) || [];
        let stars = [], collectedStars = [], enemies = [], mazeWalls = [], iceProjectiles = [];
        let isFPS = false, isGameOver = false, isPaused = true;

        // --- Store Data ---
        const ballSkins = [
            { id: 'classic', name: 'Classic', colors: ['#ffcc00', '#0044cc'], star: '#cc0000', price: 0 },
            { id: 'ruby', name: 'Ruby Strike', colors: ['#aa0000', '#330000'], star: '#ff0000', price: 100 },
            { id: 'emerald', name: 'Emerald Forest', colors: ['#00ff44', '#002200'], star: '#ffffff', price: 250 },
            { id: 'galaxy', name: 'Galaxy Void', colors: ['#110022', '#440088'], star: '#00ffff', price: 500 },
            { id: 'golden', name: 'Golden Legend', colors: ['#ffd700', '#8b4513'], star: '#ffffff', price: 1000 }
        ];
        let unlockedSkins = JSON.parse(localStorage.getItem('starball_unlocked')) || ['classic'];
        let selectedSkin = localStorage.getItem('starball_skin') || 'classic';

        const levels = [
            { grid: 9, stars: 5, enemies: 1, tracking: false },
            { grid: 9, stars: 8, enemies: 2, tracking: false },
            { grid: 10, stars: 12, enemies: 3, tracking: true },
            { grid: 10, stars: 15, enemies: 4, tracking: true },
            { grid: 11, stars: 20, enemies: 5, tracking: true }
        ];

        const baseMaze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],
            [1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1],
            [1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1],
            [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1],
            [1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1],
            [1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,1],
            [1,0,0,0,1,0,0,0,0,0,1,0,1,1,1,0,1],
            [1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,0,1],
            [1,0,1,0,0,0,0,0,1,0,1,1,1,0,1,0,1],
            [1,0,1,1,1,0,1,0,1,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        const BALL_RADIUS = 1.55; 
        const PLAYER_SPEED = 0.5; 
        const WALL_HEIGHT = 4.5;
        let offsetX, offsetZ;
        const keys = { w: false, a: false, s: false, d: false };
        let currentCameraPos = new THREE.Vector3();

        window.onload = () => {
            updateCoinDisplay();
            initThree();
            renderLevelButtons();
            renderShop();
        };

        function updateCoinDisplay() {
            document.getElementById('global-coins').innerText = globalCoins;
            localStorage.setItem('starball_coins', globalCoins);
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050000); 
            clock = new THREE.Clock();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1500);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            window.addEventListener('keydown', e => { 
                const k = e.key.toLowerCase(); if(keys.hasOwnProperty(k)) keys[k] = true;
                if(e.code === 'Space') handleCameraToggle();
                if(k === 'f') handleShoot();
            });
            window.addEventListener('keyup', e => { 
                const k = e.key.toLowerCase(); if(keys.hasOwnProperty(k)) keys[k] = false;
            });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            animate();
        }

        // --- Navigation ---
        function showLevelSelect() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('level-select').style.display = 'flex';
            renderLevelButtons();
        }

        function openShop() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('shop-screen').style.display = 'flex';
            renderShop();
        }

        function backToMenu() {
            isPaused = true;
            isGameOver = false;
            document.getElementById('level-select').style.display = 'none';
            document.getElementById('shop-screen').style.display = 'none';
            document.getElementById('message').style.display = 'none';
            document.getElementById('game-ui').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
        }

        function startGame(levelIndex) {
            currentLevel = levelIndex + 1;
            isPaused = false;
            document.getElementById('level-select').style.display = 'none';
            document.getElementById('game-ui').style.display = 'block';
            setupGame();
        }

        function renderLevelButtons() {
            const container = document.getElementById('level-buttons');
            container.innerHTML = '';
            levels.forEach((lvl, i) => {
                const card = document.createElement('div');
                card.className = 'lvl-card';
                const isCompleted = completedLevels.includes(i + 1);
                card.innerHTML = `
                    <div class="lvl-status">${isCompleted ? 'COMPLETED' : ''}</div>
                    <button class="menu-btn" style="min-width:140px; font-size:18px;">LVL ${i+1}</button>
                `;
                card.querySelector('button').onclick = () => startGame(i);
                container.appendChild(card);
            });
        }

        function renderShop() {
            const grid = document.getElementById('shop-grid');
            grid.innerHTML = '';
            ballSkins.forEach(skin => {
                const isUnlocked = unlockedSkins.includes(skin.id);
                const isSelected = selectedSkin === skin.id;
                const item = document.createElement('div');
                item.className = `shop-item ${isSelected ? 'selected' : ''}`;
                item.innerHTML = `
                    <div class="ball-preview" style="background: linear-gradient(135deg, ${skin.colors[0]}, ${skin.colors[1]})"></div>
                    <div style="font-weight:bold; font-size:14px; margin-bottom:5px;">${skin.name}</div>
                    <span class="price-tag">${isUnlocked ? 'OWNED' : skin.price + ' Coins'}</span>
                    <button class="menu-btn secondary" style="min-width:100px; font-size:14px; padding:8px 0;">
                        ${isSelected ? 'EQUIPPED' : (isUnlocked ? 'EQUIP' : 'BUY')}
                    </button>
                `;
                item.querySelector('button').onclick = () => {
                    if (isUnlocked) {
                        selectedSkin = skin.id;
                        localStorage.setItem('starball_skin', selectedSkin);
                    } else if (globalCoins >= skin.price) {
                        globalCoins -= skin.price;
                        unlockedSkins.push(skin.id);
                        localStorage.setItem('starball_unlocked', JSON.stringify(unlockedSkins));
                        selectedSkin = skin.id;
                        localStorage.setItem('starball_skin', selectedSkin);
                        updateCoinDisplay();
                    }
                    renderShop();
                };
                grid.appendChild(item);
            });
        }

        // --- Core Setup & Logic (Kalan kodlar öncekiyle aynı kalıyor) ---
        function setupGame() {
            const lvl = levels[currentLevel-1];
            score = 0;
            isGameOver = false;
            isFPS = false;
            document.getElementById('score').innerText = score;
            document.getElementById('target-score').innerText = lvl.stars;
            document.getElementById('current-level-display').innerText = currentLevel;
            document.getElementById('message').style.display = "none";
            while(scene.children.length > 0){ scene.remove(scene.children[0]); }
            scene.add(new THREE.AmbientLight(0xffcccc, 0.4));
            const pointLight = new THREE.PointLight(0xffffff, 1.5, 1500);
            pointLight.position.set(0, 200, 0);
            scene.add(pointLight);
            stars = []; collectedStars = []; enemies = []; mazeWalls = []; iceProjectiles = [];
            offsetX = (baseMaze[0].length * lvl.grid) / 2;
            offsetZ = (baseMaze.length * lvl.grid) / 2;
            createWorld(lvl);
            createPlayer();
            spawnItems(lvl);
            currentCameraPos.copy(player.position).add(new THREE.Vector3(0, 45, 25));
        }

        function createWorld(lvl) {
            const floorGeo = new THREE.PlaneGeometry(2000, 2000);
            const floorMat = new THREE.MeshPhongMaterial({ color: 0x110000 }); 
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);
            const wallGeo = new THREE.BoxGeometry(lvl.grid, WALL_HEIGHT, lvl.grid);
            const wallMat = new THREE.MeshPhongMaterial({ color: 0x0000bb });
            for(let z = 0; z < baseMaze.length; z++) {
                for(let x = 0; x < baseMaze[0].length; x++) {
                    if(baseMaze[z][x] === 1) {
                        const wall = new THREE.Mesh(wallGeo, wallMat);
                        wall.position.set(x * lvl.grid - offsetX + lvl.grid/2, WALL_HEIGHT/2, z * lvl.grid - offsetZ + lvl.grid/2);
                        scene.add(wall);
                        mazeWalls.push(wall);
                    }
                }
            }
        }

        function getSafePos() {
            const lvl = levels[currentLevel-1];
            let rx, rz;
            do {
                rx = Math.floor(Math.random() * baseMaze[0].length);
                rz = Math.floor(Math.random() * baseMaze.length);
            } while (baseMaze[rz][rx] !== 0);
            return new THREE.Vector3(rx * lvl.grid - offsetX + lvl.grid/2, BALL_RADIUS, rz * lvl.grid - offsetZ + lvl.grid/2);
        }

        function createPlayer() {
            player = new THREE.Group();
            player.position.copy(getSafePos());
            scene.add(player);
            playerBall = new THREE.Group();
            player.add(playerBall);
            const skin = ballSkins.find(s => s.id === selectedSkin);
            const topMat = new THREE.MeshPhongMaterial({ color: skin.colors[0], shininess: 100 });
            const botMat = new THREE.MeshPhongMaterial({ color: skin.colors[1], shininess: 100 });
            const starMat = new THREE.MeshPhongMaterial({ color: skin.star, shininess: 200 });
            const upperSphere = new THREE.Mesh(new THREE.SphereGeometry(BALL_RADIUS, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2), topMat);
            const lowerSphere = new THREE.Mesh(new THREE.SphereGeometry(BALL_RADIUS, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2), botMat);
            playerBall.add(upperSphere, lowerSphere);
            const starShape = new THREE.Shape();
            const spikes = 5;
            for (let i = 0; i < spikes * 2; i++) {
                const r = i % 2 === 0 ? 0.8 : 0.35;
                const a = (i / (spikes * 2)) * Math.PI * 2 - Math.PI / 2;
                if (i === 0) starShape.moveTo(Math.cos(a)*r, Math.sin(a)*r);
                else starShape.lineTo(Math.cos(a)*r, Math.sin(a)*r);
            }
            const starMesh = new THREE.Mesh(new THREE.ExtrudeGeometry(starShape, { depth: 0.1, bevelEnabled: false }), starMat);
            starMesh.rotation.x = -Math.PI / 2;
            starMesh.position.y = BALL_RADIUS - 0.05;
            playerBall.add(starMesh);
        }

        function spawnItems(lvl) {
            const starGeo = new THREE.CylinderGeometry(0.9, 0.9, 0.4, 32);
            const starMat = new THREE.MeshPhongMaterial({ color: 0xffff00 });
            for(let i=0; i < lvl.stars; i++) {
                const star = new THREE.Mesh(starGeo, starMat);
                star.position.copy(getSafePos()).setY(2.2);
                star.rotation.x = Math.PI / 2;
                scene.add(star);
                stars.push(star);
            }
            for(let i=0; i < lvl.enemies; i++) {
                const enemy = new THREE.Group();
                enemy.position.copy(getSafePos());
                const body = new THREE.Mesh(new THREE.SphereGeometry(BALL_RADIUS, 32, 32), new THREE.MeshPhongMaterial({ color: 0x9900ee }));
                enemy.add(body);
                const ice = new THREE.Mesh(new THREE.IcosahedronGeometry(BALL_RADIUS * 1.3, 1), new THREE.MeshPhongMaterial({ color: 0x00ffff, transparent: true, opacity: 0 }));
                enemy.add(ice);
                enemy.userData = { 
                    dir: new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), Math.random()*Math.PI*2), 
                    frozen: 0, ice: ice, tracking: lvl.tracking
                };
                scene.add(enemy);
                enemies.push(enemy);
            }
        }

        function checkCollision(pos) {
            const lvl = levels[currentLevel-1];
            const margin = BALL_RADIUS + 0.3; 
            for (let z = 0; z < baseMaze.length; z++) {
                for (let x = 0; x < baseMaze[0].length; x++) {
                    if (baseMaze[z][x] === 1) {
                        const wx = x * lvl.grid - offsetX + lvl.grid/2;
                        const wz = z * lvl.grid - offsetZ + lvl.grid/2;
                        if (Math.abs(pos.x - wx) < (lvl.grid/2 + margin) && Math.abs(pos.z - wz) < (lvl.grid/2 + margin)) return true;
                    }
                }
            }
            return false;
        }

        function handleCameraToggle() {
            if (isGameOver || isPaused) return;
            isFPS = !isFPS;
            playerBall.visible = !isFPS;
            document.getElementById('crosshair').style.display = isFPS ? 'block' : 'none';
        }

        function handleShoot() {
            if (isGameOver || isPaused) return;
            const ice = new THREE.Mesh(new THREE.SphereGeometry(0.7, 8, 8), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
            ice.position.copy(player.position);
            const vec = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            ice.userData = { vel: vec.multiplyScalar(2.2) };
            scene.add(ice);
            iceProjectiles.push(ice);
        }

        function updatePlayer() {
            if (isGameOver || isPaused || !player) return;
            const prev = player.position.clone();
            let move = new THREE.Vector3(0,0,0);
            if (isFPS) {
                if (keys.w) move.z -= 1;
                if (keys.s) move.z += 1;
                if (keys.a) player.rotation.y += 0.05;
                if (keys.d) player.rotation.y -= 0.05;
                move.applyMatrix4(new THREE.Matrix4().makeRotationY(player.rotation.y));
            } else {
                if (keys.w) move.z -= 1;
                if (keys.s) move.z += 1;
                if (keys.a) move.x -= 1;
                if (keys.d) move.x += 1;
                if (move.length() > 0) {
                    const targetAngle = Math.atan2(move.x, move.z);
                    let diff = targetAngle - player.rotation.y;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    player.rotation.y += diff * 0.15; 
                }
            }
            if (move.length() > 0) {
                move.normalize().multiplyScalar(PLAYER_SPEED);
                player.position.x += move.x;
                if (checkCollision(player.position)) player.position.x = prev.x;
                player.position.z += move.z;
                if (checkCollision(player.position)) player.position.z = prev.z;
                if (!player.position.equals(prev)) {
                    playerBall.rotation.x -= (player.position.distanceTo(prev)) / BALL_RADIUS;
                }
            }
            if (isFPS) {
                camera.position.set(player.position.x, player.position.y + 1, player.position.z);
                camera.quaternion.copy(player.quaternion);
            } else {
                const target = new THREE.Vector3(player.position.x, player.position.y + 45, player.position.z + 25);
                currentCameraPos.lerp(target, 0.1);
                camera.position.copy(currentCameraPos);
                camera.lookAt(player.position.x, player.position.y, player.position.z);
            }
            for (let i = stars.length - 1; i >= 0; i--) {
                if (player.position.distanceTo(stars[i].position) < 3.0) {
                    score++;
                    globalCoins += 10;
                    updateCoinDisplay();
                    document.getElementById('score').innerText = score;
                    collectedStars.push({ mesh: stars[i], life: 1.0, vel: new THREE.Vector3(0, 0.5, 0) });
                    stars.splice(i, 1);
                    if(score >= levels[currentLevel-1].stars) winGame();
                }
            }
        }

        function updateEnemies(dt) {
            const enemySpeed = 0.28 + (currentLevel * 0.03);
            enemies.forEach(enemy => {
                const ud = enemy.userData;
                if (ud.frozen > 0) {
                    ud.frozen -= dt;
                    ud.ice.material.opacity = 0.7;
                    return;
                }
                ud.ice.material.opacity = 0;
                const prev = enemy.position.clone();
                if (ud.tracking && player.position.distanceTo(enemy.position) < 40) {
                    const toPlayer = player.position.clone().sub(enemy.position).normalize();
                    ud.dir.lerp(toPlayer, 0.05);
                }
                enemy.position.add(ud.dir.clone().multiplyScalar(enemySpeed));
                if (checkCollision(enemy.position)) {
                    enemy.position.copy(prev);
                    ud.dir.applyAxisAngle(new THREE.Vector3(0,1,0), (Math.random() * Math.PI + Math.PI/2));
                }
                if (!isGameOver && enemy.position.distanceTo(player.position) < 3.0) gameOver();
            });
            for (let i = iceProjectiles.length - 1; i >= 0; i--) {
                const p = iceProjectiles[i];
                p.position.add(p.userData.vel);
                if (checkCollision(p.position)) { scene.remove(p); iceProjectiles.splice(i, 1); continue; }
                enemies.forEach(e => {
                    if (p.position.distanceTo(e.position) < 3.0) {
                        e.userData.frozen = 3.0; 
                        scene.remove(p); iceProjectiles.splice(i, 1);
                    }
                });
            }
        }

        function winGame() {
            isGameOver = true;
            if (!completedLevels.includes(currentLevel)) {
                completedLevels.push(currentLevel);
                localStorage.setItem('starball_completed', JSON.stringify(completedLevels));
            }
            const m = document.getElementById('message');
            document.getElementById('msg-content').innerHTML = `<span style="color:gold">LEVEL ${currentLevel} COMPLETE!</span><br><span style="font-size:18px">Well done! You earned bonus coins.</span>`;
            const nextBtn = document.getElementById('next-lvl-btn');
            if (currentLevel < levels.length) {
                nextBtn.style.display = "block";
                nextBtn.onclick = () => startGame(currentLevel);
            } else { nextBtn.style.display = "none"; }
            m.style.display = "block";
        }

        function gameOver() {
            isGameOver = true;
            const m = document.getElementById('message');
            document.getElementById('msg-content').innerHTML = `<span style="color:#ff3333">GAME OVER</span><br><span style="font-size:18px">The enemy caught you!</span>`;
            document.getElementById('next-lvl-btn').style.display = "none";
            m.style.display = "block";
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!isPaused) {
                updatePlayer();
                updateEnemies(clock.getDelta());
                stars.forEach(s => s.rotation.y += 0.05);
                for (let i = collectedStars.length - 1; i >= 0; i--) {
                    let cc = collectedStars[i];
                    cc.mesh.position.add(cc.vel);
                    cc.mesh.scale.multiplyScalar(0.9);
                    cc.life -= 0.05;
                    if (cc.life <= 0) { scene.remove(cc.mesh); collectedStars.splice(i, 1); }
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>